# 六大设计原则

- **开闭原则是目标，里氏代换原则是基础，依赖倒置原则是手段**，它们相辅相成，相互补充，目标一致，只是分析问题时所站角度不同而已。

## 一、单一职责原则（SRP）
### 1、一些名词
* `Single Responsibility Principle`，简称是**SRP**
* **RBAC模型**（Role-Based Access Control，基于角色的访问控制，通过分配和取消角色来完成用户权限的授予和取消，使动作主体（用户）与资源的行为（权限）分离。
* BO（Bussiness Object，业务对象）
* Biz（Business Logic，业务逻辑）
<div align=“center”><img src="./img/001.png"></div>

### 2、单一职责原则
- 单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。单一职责原则定义如下：
* 单一职责原则的**定义**是：**单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。**（应该有且仅有一个原因引起类的变更。）
* SRP的原话解释是：There should never be more than one reason for a class to change.（一个类改变的原因不应该不止一个。）
<div align=“center”><img src="./img/002.png"></div>

* 单一职责原则有什么好处：
  * 类的复杂性降低，实现什么职责都有清晰明确的定义；
  * 可读性提高，复杂性降低，那当然可读性提高了；
  * 可维护性提高，可读性提高，那当然更容易维护了；
  * 变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。
* **单一职责原则**提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否优良，但是“职责”和“变化原因”都是不可度量的，因项目而异，因环境而异。

### 3、单一原则的实施与用途
- 单一原则的实施:
  - 对于接口，我们在设计的时候一定要做到单一，但是对于实现类就需要多方面考虑了。
  - 生搬硬套单一职责原则会引起类的剧增，给维护带来非常多的麻烦，而且过分细分类的职责也会人为地增加系统的复杂性。
  - 本来一个类可以实现的行为硬要拆成两个类，然后再使用聚合或组合的方式耦合在一起，人为制造了系统的复杂性。
  - 所以原则是死的，人是活的，这句话很有道理。
- 单一职责的用途
  - 适用于**接口**、**类**，同时也适用于**方法**。
  - 单一职责在**方法**中的应用：
    - **一个方法尽可能做一件事情**，比如一个方法修改用户密码，不要把这个方法放到“修改用户信息”方法中，这个方法的颗粒度很粗。
  - 类的单一职责：
    - "This is sometimes hard to see"，这句话翻译过来就是“这个有时候很难说”。
- 对于单一职责原则
  - 接口一定要做到单一职责；
  - 类的设计尽量做到只有一个原因引起变化。

## 二、里氏替换原则（LSP）
### 1、继承的优缺点
- 优点：
  - 代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性；
  - 提高代码的重用性；
  - 子类可以形似父类，但又异于父类，“龙生龙，凤生凤，老鼠生来会打洞”是说子拥有父的“种”，“世界上没有两片完全相同的叶子”是指明子与父的不同；
  - 提高代码的可扩展性，实现父类的方法就可以“为所欲为”了，君不见很多开源框架的扩展接口都是通过继承父类来完成的；
  - 提高产品或项目的开放性。
- 缺点：
  - 继承是侵入性的。只要继承，就必须拥有父类的所有属性和方法；
  - 降低代码的灵活性。子类必须拥有父类的属性和方法，让子类自由的世界中多了些约束；
  - 增强了耦合性。当父类的常量、变量和方法被修改时，必需要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的结果——大片的代码需要重构。

### 2、里氏替换原则

* 里氏替换原则（Liskov Substitution Principle,LSP）
* 定义：
  * 第一种定义，也是最正宗的定义：If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T,the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.（如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。）
  * 第二种定义：Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.（所有引用基类的地方必须能透明地使用其子类的对象。）
  * 第二个定义是最清晰明确的，通俗点讲，**只要父类能出现的地方子类就可以出现**，**而且替换为子类也不会产生任何错误或异常**，使用者可能根本就不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应。**（子类可以替换父类，父类不一定能替换子类）**
  * 里氏代换原则告诉我们，**在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。**例如：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢动物，因为我并不喜欢老鼠，虽然它也是动物。
  * 里氏代换原则是实现**开闭原则**的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此**在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象**。
- **里氏替换原则**为良好的继承定义了一个规范，一句简单的定义包含了4层含义。 
  - 1.**子类必须完全实现父类的方法**（继承就是告诉你拥有父类的方法和属性，然后你就可以重写父类的方法。）
    - 注意：在类中调用其他类时务必要**使用父类或接口**，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则。
    - 注意：如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承。
  - 2.**子类可以有自己的个性**（里氏替换原则可以正着用，但是不能反过来用。**在子类出现的地方，父类未必就可以胜任**。）
    - 向上类型转换（猫是动物）；向下类型转换（动物是猫<有些情况下会失败>）
  - 3.覆盖或实现父类的方法时输入参数可以被放大
    - 子类中方法的前置条件（传入参数）必须与超类中被覆写的方法的前置条件（传入参数）相同或者更宽松。
    - 传入参数相同：复写/重写
    - 传入参数不相同（更宽松）：重载
  - 4.覆写或实现父类的方法时输出结果可以被缩小
  	- 父类的一个方法的返回值是一个类型T，子类的相同方法（重载或覆写）的返回值为S，那么里氏替换原则就要求S必须小于等于T，也就是说，要么S和T是同一个类型，要么S是T的子类。
  	- 如果是**覆写**，父类和子类的同名方法的输入参数是相同的，两个方法的返回值S小于等于T，这是覆写的要求，这才是重中之重，子类覆写父类的方法，天经地义。
  	- 如果是**重载**，则要求方法的输入参数类型或数量不相同，在里氏替换原则要求下，就是子类的输入参数宽于或等于父类的输入参数，也就是说你写的这个方法是不会被调用的。
- 采用里氏替换原则的**目的**就是增强程序的健壮性，版本升级时也可以保持非常好的兼容性。即使增加子类，原有的子类还可以继续运行。
- 在实际项目中，每个子类对应不同的业务含义，使用父类作为参数，传递不同的子类完成不同的业务逻辑，非常完美！

### 3、里氏替换原则实践

- 在项目中，采用里氏替换原则时，尽量避免子类的“个性”，一旦子类有“个性”，这个子类和父类之间的关系就很难调和了，
- 把子类当做父类使用，子类的“个性”被抹杀——委屈了点；
- 把子类单独作为一个业务来使用，则会让代码间的耦合关系变得扑朔迷离——缺乏类替换的标准。

## 三、依赖倒置原则（DIP（面向接口编程））
### 1、依赖倒置原则的定义

- 依赖倒置原则（Dependence Inversion Principle,DIP）
- 原始定义是：`High level modules should not depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details.Details should depend upon abstractions.`
- **依赖倒转原则(Dependency Inversion  Principle, DIP)：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。**
- 翻译过来，包含三层含义：
  - 高层模块不应该依赖低层模块，两者都应该依赖其抽象；
  - 抽象不应该依赖细节；
  - 细节应该依赖抽象。
- 名词解释：
  - 高层模块和低层模块容易理解，每一个逻辑的实现都是由原子逻辑组成的，不可分割的原子逻辑就是**低层模块**，原子逻辑的再组装就是**高层模块**。
  - 在Java语言中，**抽象**就是指接口或抽象类，两者都是不能直接被实例化的；**细节**就是实现类，实现接口或继承抽象类而产生的类就是细节，其特点就是可以直接被实例化，也就是可以加上一个关键字new产生一个对象。
- 依赖倒置原则在Java语言中的表现就是：
  - 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的；
  - 接口或抽象类不依赖于实现类；
  - 实现类依赖接口或抽象类。
- 更加精简的定义就是“面向接口编程”——OOD（Object-Oriented Design，面向对象设计）的精髓之一。

### 2、依赖倒置原则的应用
- **依赖倒转原则要求**我们在程序代码中传递参数时或在关联关系中，**尽量引用层次高的抽象层类**，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。
- **在实现依赖倒置原则时**，我们需要针对抽象层编程，而将具体类的对象通过**依赖注入(DependencyInjection, DI)**的方式注入到其他对象中，**依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象**。常用的注入方式有三种，分别是：**构造注入（构造函数），设值注入（Setter注入）和接口注入**。
  - **构造注入**是指通过构造函数来传入具体类的对象，
  - **设值注入**是指通过Setter方法来传入具体类的对象，
  - **接口注入**是指通过在接口中声明的业务方法来传入具体类的对象。
  - 这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。

### 3、依赖倒置原则的好处

- 采用依赖倒置原则：
  - 可以减少类间的耦合性，
  - 提高系统的稳定性，
  - 降低并行开发引起的风险，
  - 提高代码的可读性和可维护性。
- 

## 四、接口隔离原则（ISP）

### 1、接口隔离原则的定义
- 定义：**接口隔离原则(Interface  Segregation Principle, ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。**
- 根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。**每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。**
- 这里的“接口”往往有两种不同的含义：
  - 一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象；
  - 另外一种是指某种语言具体的“接口”定义，有严格的定义和结构，比如Java语言中的interface。
  - 对于这两种不同的含义，ISP的表达方式以及含义都有所不同：
    - (1) 当把“接口”理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以叫做“**角色隔离原则**”。
    - (2) 如果把“接口”理解成狭义的特定语言的接口，那么ISP表达的意思是指**接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口**。
      - 在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，因此大的总接口使用起来不一定很方便，为了使接口的职责单一，需要将大接口中的方法根据其职责不同分别放在不同的小接口中，以确保每个接口使用起来都较为方便，并都承担某一单一角色。

      - 接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端（如子模块或业务逻辑类）所需的方法即可，这种机制也称为“**定制服务**”，即为不同的客户端提供宽窄不同的接口。
- **在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。**一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些它们不用的方法。



## 五、迪米特法则（LoD）
### 1、迪米特法则的定义
- 定义：**迪米特法则(Law of  Demeter, LoD)：一个软件实体应当尽可能少地与其他实体发生相互作用。**
-  如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。**迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。**
### 2、迪米特法则还有几种定义形式
- **不要和“陌生人”说话**、**只与你的直接朋友通信**等，在迪米特法则中，对于一个对象，其朋友包括以下几类：
  -  (1) 当前对象本身(this)；
  -  (2) 以参数形式传入到当前对象方法中的对象；
  - (3) 当前对象的成员对象；
  - (4) 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；
  - (5) 当前对象所创建的对象。
- 任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”。
- 在应用迪米特法则时，一个对象只能与直接朋友发生交互，不要与“陌生人”发生直接交互，这样做可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。
### 3、迪米特法则的应用
- 迪米特法则要求我们在设计系统时，**应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用**。简言之，就是**通过引入一个合理的第三者来降低现有对象之间的耦合度**。
- 在将迪米特法则运用到系统设计中时，要注意下面的几点：
  - **在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及**；
  - **在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限**；
  - **在类的设计上，只要有可能，一个类型应当设计成不变类**；
  - **在对其他类的引用上，一个对象对其他对象的引用应当降到最低**。

## 六、开闭原则（OCP）
### 1、开闭原则的定义
- 开闭原则是面向对象的可复用设计的第一块基石，它是最重要的面向对象设计原则。开闭原则由**Bertrand  Meyer**于1988年提出，其定义如下：
- 定义：**开闭原则(Open-Closed Principle, OCP)：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。**
- 在开闭原则的定义中，**软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类**。

### 2、开闭原则的应用
- 为了满足开闭原则，需要对系统进行抽象化设计，**抽象化是开闭原则的关键**。
- 在Java、C#等编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。