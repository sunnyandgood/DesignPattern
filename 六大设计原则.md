# 六大设计原则
## 一、单一职责原则（SRP）
### 1、一些名词
* `Single Responsibility Principle`，简称是**SRP**
* **RBAC模型**（Role-Based Access Control，基于角色的访问控制，通过分配和取消角色来完成用户权限的授予和取消，使动作主体（用户）与资源的行为（权限）分离。
* BO（Bussiness Object，业务对象）
* Biz（Business Logic，业务逻辑）
<div align=“center”><img src="./img/001.png"></div>

### 2、单一职责原则
* 单一职责原则的**定义**是：应该有且仅有一个原因引起类的变更。
* SRP的原话解释是：There should never be more than one reason for a class to change.（一个类改变的原因不应该不止一个。）
<div align=“center”><img src="./img/002.png"></div>

* 单一职责原则有什么好处：
  * 类的复杂性降低，实现什么职责都有清晰明确的定义；
  * 可读性提高，复杂性降低，那当然可读性提高了；
  * 可维护性提高，可读性提高，那当然更容易维护了；
  * 变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。
* **单一职责原则**提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否优良，但是“职责”和“变化原因”都是不可度量的，因项目而异，因环境而异。

### 3、单一原则的实施与用途
- 单一原则的实施:
  - 对于接口，我们在设计的时候一定要做到单一，但是对于实现类就需要多方面考虑了。
  - 生搬硬套单一职责原则会引起类的剧增，给维护带来非常多的麻烦，而且过分细分类的职责也会人为地增加系统的复杂性。
  - 本来一个类可以实现的行为硬要拆成两个类，然后再使用聚合或组合的方式耦合在一起，人为制造了系统的复杂性。
  - 所以原则是死的，人是活的，这句话很有道理。
- 单一职责的用途
  - 适用于**接口**、**类**，同时也适用于**方法**。
  - 单一职责在**方法**中的应用：
    - **一个方法尽可能做一件事情**，比如一个方法修改用户密码，不要把这个方法放到“修改用户信息”方法中，这个方法的颗粒度很粗。
  - 类的单一职责：
    - "This is sometimes hard to see"，这句话翻译过来就是“这个有时候很难说”。
- 对于单一职责原则
  - 接口一定要做到单一职责；
  - 类的设计尽量做到只有一个原因引起变化。

## 二、里氏替换原则（LSP）
### 1、继承的优缺点
- 优点：
  - 代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性；
  - 提高代码的重用性；
  - 子类可以形似父类，但又异于父类，“龙生龙，凤生凤，老鼠生来会打洞”是说子拥有父的“种”，“世界上没有两片完全相同的叶子”是指明子与父的不同；
  - 提高代码的可扩展性，实现父类的方法就可以“为所欲为”了，君不见很多开源框架的扩展接口都是通过继承父类来完成的；
  - 提高产品或项目的开放性。
- 缺点：
  - 继承是侵入性的。只要继承，就必须拥有父类的所有属性和方法；
  - 降低代码的灵活性。子类必须拥有父类的属性和方法，让子类自由的世界中多了些约束；
  - 增强了耦合性。当父类的常量、变量和方法被修改时，必需要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的结果——大片的代码需要重构。

### 2、里氏替换原则

* 里氏替换原则（Liskov Substitution Principle,LSP）
* 定义：
  * 第一种定义，也是最正宗的定义：If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T,the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.（如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。）
  * 第二种定义：Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.（所有引用基类的地方必须能透明地使用其子类的对象。）
  * 第二个定义是最清晰明确的，通俗点讲，**只要父类能出现的地方子类就可以出现**，**而且替换为子类也不会产生任何错误或异常**，使用者可能根本就不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应。**（子类可以替换父类，父类不一定能替换子类）**
- **里氏替换原则**为良好的继承定义了一个规范，一句简单的定义包含了4层含义。 
  - 1.**子类必须完全实现父类的方法**（继承就是告诉你拥有父类的方法和属性，然后你就可以重写父类的方法。）
    - 注意：在类中调用其他类时务必要**使用父类或接口**，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则。
    - 注意：如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承。
  - 2.**子类可以有自己的个性**（里氏替换原则可以正着用，但是不能反过来用。**在子类出现的地方，父类未必就可以胜任**。）
    - 向上类型转换（猫是动物）；向下类型转换（动物是猫<有些情况下会失败>）
  - 3.覆盖或实现父类的方法时输入参数可以被放大
    - 子类中方法的前置条件（传入参数）必须与超类中被覆写的方法的前置条件（传入参数）相同或者更宽松。
    - 传入参数相同：复写/重写
    - 传入参数不相同（更宽松）：重载
  - 4.覆写或实现父类的方法时输出结果可以被缩小
  	- 父类的一个方法的返回值是一个类型T，子类的相同方法（重载或覆写）的返回值为S，那么里氏替换原则就要求S必须小于等于T，也就是说，要么S和T是同一个类型，要么S是T的子类。
  	- 如果是**覆写**，父类和子类的同名方法的输入参数是相同的，两个方法的返回值S小于等于T，这是覆写的要求，这才是重中之重，子类覆写父类的方法，天经地义。
  	- 如果是**重载**，则要求方法的输入参数类型或数量不相同，在里氏替换原则要求下，就是子类的输入参数宽于或等于父类的输入参数，也就是说你写的这个方法是不会被调用的。
- 采用里氏替换原则的**目的**就是增强程序的健壮性，版本升级时也可以保持非常好的兼容性。即使增加子类，原有的子类还可以继续运行。
- 在实际项目中，每个子类对应不同的业务含义，使用父类作为参数，传递不同的子类完成不同的业务逻辑，非常完美！

### 3、里氏替换原则实践

- 在项目中，采用里氏替换原则时，尽量避免子类的“个性”，一旦子类有“个性”，这个子类和父类之间的关系就很难调和了，
- 把子类当做父类使用，子类的“个性”被抹杀——委屈了点；
- 把子类单独作为一个业务来使用，则会让代码间的耦合关系变得扑朔迷离——缺乏类替换的标准。

## 三、依赖倒置原则（DIP（面向接口编程））
### 1、依赖倒置原则的定义

- 依赖倒置原则（Dependence Inversion Principle,DIP）
- 原始定义是：`High level modules should not depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details.Details should depend upon abstractions.`
- 翻译过来，包含三层含义：
  - 高层模块不应该依赖低层模块，两者都应该依赖其抽象；
  - 抽象不应该依赖细节；
  - 细节应该依赖抽象。
- 名词解释：
  - 高层模块和低层模块容易理解，每一个逻辑的实现都是由原子逻辑组成的，不可分割的原子逻辑就是**低层模块**，原子逻辑的再组装就是**高层模块**。
  - 在Java语言中，**抽象**就是指接口或抽象类，两者都是不能直接被实例化的；**细节**就是实现类，实现接口或继承抽象类而产生的类就是细节，其特点就是可以直接被实例化，也就是可以加上一个关键字new产生一个对象。
- 依赖倒置原则在Java语言中的表现就是：
  - 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的；
  - 接口或抽象类不依赖于实现类；
  - 实现类依赖接口或抽象类。
- 更加精简的定义就是“面向接口编程”——OOD（Object-Oriented Design，面向对象设计）的精髓之一。

### 2、依赖导致原则的好处

- 采用依赖倒置原则：
  - 可以减少类间的耦合性，
  - 提高系统的稳定性，
  - 降低并行开发引起的风险，
  - 提高代码的可读性和可维护性。
- 













## 四、接口隔离原则


## 五、迪米特法则


## 六、开闭原则